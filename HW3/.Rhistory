format(Sys.Date(), "%B")
format(Sys.Date(), "%b")
format(Sys.Date(), "%M")
format(Sys.Date(), "%m")
format(Sys.Date(), "%I")
format(Sys.Date(), "%P")
format(Sys.Date(), "%Q")
format(Sys.Date(), "%i")
format(Sys.Date(), "%p")
format(Sys.Date(), "%t")
format(Sys.Date(), "%D")
format(Sys.Date(), "%d")
format(Sys.Date(), "%h")
format(Sys.Date(), "%H")
# Chunk 1: setup
knitr::opts_chunk$set(
echo = FALSE,
message = FALSE,
warning = FALSE
)
# Chunk 2: load_packages
if(!require(pacman)) install.packages("pacman")
pacman::p_load(
pacman,
tidyverse,
flextable,
knitr
)
prod <- c(100, 200, 100)
attr <- c(200, 50, 150)
costs <- matrix(c(2, 5, 4,
5, 2, 3,
4, 3, 2),
byrow = T,
nrow = 3)
costs
#' Gravity Model
#' @param p vector of productions, length n
#' @param A vector of attractions, lenth n
#' @param C matrix of impedances, dim n x n
#' @param b impedance parameter
gravity <- function(p, a, C, b){
# output matrix (all 0 here)
trips <- matrix(0, nrow = length(p), ncol = length(a))
# loop over all rows (production)
for (i in 1:length(p)) {
bottomA <- sum(a * C[i, ]^(-b)) # denominator
# loop over all columns (attraction)
for (j in 1:length(a)) {
# calculate gravity model for trips from i to j
topA <- a[j] * C[i,j]^(-b)
trips[i, j] <-  p[i] * topA / bottomA
}
}
return(trips)
}
#' Function to balance gravity model
#' @param p vector of productions, length n
#' @param A vector of attractions, length n
#' @param C matrix of impedances, dim n x n
#' @param b impedance parameter
#' @param tolerance Acceptable change in trips matrix
balance_gravity <- function(p, a, C, b, tolerance) {
# define starting values
k <- 0 #iteration counter
astar <- a # starting unadjusted attractions
trips0 <- matrix(0, nrow = length(p), ncol = length(a)) #initial T is 0's
error <- Inf # first time through, error is Infinite
# loop through algorithm
while(error > tolerance){
# compute gravity model with adjusted attractions, using your function
trips <- gravity(p, astar, C, b)
# calculate the error as the change in trips in successive iterations
error <- sum(abs(trips - trips0))
# protect against infinite loops, increment values
if (k > 100) break # maximum of 100 iterations
k <- k + 1
trips0 <- trips
astar <- astar * a / colSums(trips) # next iteration astar
}
return(trips)
}
# Chunk 1: setup
knitr::opts_chunk$set(
echo = FALSE,
message = FALSE,
warning = FALSE
)
# Chunk 2: load_packages
if(!require(pacman)) install.packages("pacman")
pacman::p_load(
pacman,
tidyverse,
flextable,
knitr
)
# Chunk 3: grav_model
#' Gravity Model
#' @param p vector of productions, length n
#' @param A vector of attractions, lenth n
#' @param C matrix of impedances, dim n x n
#' @param b impedance parameter
gravity <- function(p, a, C, b){
# output matrix (all 0 here)
trips <- matrix(0, nrow = length(p), ncol = length(a))
# loop over all rows (production)
for (i in 1:length(p)) {
bottomA <- sum(a * C[i, ]^(-b)) # denominator
# loop over all columns (attraction)
for (j in 1:length(a)) {
# calculate gravity model for trips from i to j
topA <- a[j] * C[i,j]^(-b)
trips[i, j] <-  p[i] * topA / bottomA
}
}
return(trips)
}
#' Function to balance gravity model
#' @param p vector of productions, length n
#' @param A vector of attractions, length n
#' @param C matrix of impedances, dim n x n
#' @param b impedance parameter
#' @param tolerance Acceptable change in trips matrix
balance_gravity <- function(p, a, C, b, tolerance) {
# define starting values
k <- 0 #iteration counter
astar <- a # starting unadjusted attractions
trips0 <- matrix(0, nrow = length(p), ncol = length(a)) #initial T is 0's
error <- Inf # first time through, error is Infinite
# loop through algorithm
while(error > tolerance){
# compute gravity model with adjusted attractions, using your function
trips <- gravity(p, astar, C, b)
# calculate the error as the change in trips in successive iterations
error <- sum(abs(trips - trips0))
# protect against infinite loops, increment values
if (k > 100) break # maximum of 100 iterations
k <- k + 1
trips0 <- trips
astar <- astar * a / colSums(trips) # next iteration astar
}
return(trips)
}
# Chunk 4
prod <- c(100, 200, 100)
attr <- c(200, 50, 150)
costs <- matrix(c(2, 5, 4,
5, 2, 3,
4, 3, 2),
byrow = T,
nrow = 3)
# Chunk 5: dist1
balance_gravity(a = attr, p = prod, C = costs, b = 0.5, tolerance = 0.01)
knitr::opts_chunk$set(
echo = TRUE,
message = FALSE,
warning = FALSE
)
tibble(c(1, 2, 3),
c(80, 80, 40),
c(5, 40, 5),
c(15, 80, 55),
) %>%
`colnames<-`(c(1, 2, 3))
tibble(c(1, 2, 3),
c(80, 80, 40),
c(5, 40, 5),
c(15, 80, 55),
) %>%
`colnames<-`(c("", 1, 2, 3))
my_flextable <- function(tibble){
flextable(tibble) %>%
autofit() %>%
align(align = "center", part = "all")
}
tibble(c(1, 2, 3),
c(80, 80, 40),
c(5, 40, 5),
c(15, 80, 55),
) %>%
`colnames<-`(c("", 1, 2, 3)) %>%
my_flextable()
tibble(c(1, 2, 3),
c(80, 80, 40),
c(5, 40, 5),
c(15, 80, 55),
) %>%
`colnames<-`(c("", 1, 2, 3))
tibble(c(1, 2, 3),
c(80, 80, 40),
c(5, 40, 5),
c(15, 80, 55),
) %>%
my_flextable()
tibble(c(1, 2, 3),
c(80, 80, 40),
c(5, 40, 5),
c(15, 80, 55),
) %>%
my_flextable() %>%
`colnames<-`(c("", 1, 2, 3))
tibble(c(1, 2, 3),
c(80, 80, 40),
c(5, 40, 5),
c(15, 80, 55),
) %>%
`colnames<-`(c("", 1, 2, 3)) %>%
my_flextable()
obs <- tibble(c(1, 2, 3),
c(80, 80, 40),
c(5, 40, 5),
c(15, 80, 55),
) %>%
colnames(obs) <- c("", "1", "2", "3")
my_flextable(obs)
obs <- tibble(c(1, 2, 3),
c(80, 80, 40),
c(5, 40, 5),
c(15, 80, 55),
) %>%
colnames(obs) <- c("", "1", "2", "3")
my_flextable(obs)
obs <- tibble(c(1, 2, 3),
c(80, 80, 40),
c(5, 40, 5),
c(15, 80, 55),
)
colnames(obs) <- c("", "1", "2", "3")
my_flextable(obs)
colnames(obs) <- c("a", "1", "2", "3")
my_flextable(obs)
colnames(obs) <- c("i\\j", "1", "2", "3")
my_flextable(obs)
obs <- tibble(c(1, 2, 3),
c(80, 80, 40),
c(5, 40, 5),
c(15, 80, 55),
)
colnames(obs) <- c("i \\ j", "1", "2", "3")
my_flextable(obs)
